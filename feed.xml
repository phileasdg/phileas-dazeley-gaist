<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Phileas Dazeley-Gaist</title>
    <link href="https://phileasdg.github.io/phileas-dazeley-gaist/feed.xml" rel="self" />
    <link href="https://phileasdg.github.io/phileas-dazeley-gaist" />
    <updated>2022-03-27T23:00:44-04:00</updated>
    <author>
        <name>Phileas Dazeley-Gaist</name>
    </author>
    <id>https://phileasdg.github.io/phileas-dazeley-gaist</id>

    <entry>
        <title>An Exploration of the Logistic Function using GAMs and Spline Regressions in R</title>
        <author>
            <name>Phileas Dazeley-Gaist</name>
        </author>
        <link href="https://phileasdg.github.io/phileas-dazeley-gaist/an-exploration-of-the-logistic-function-using-general-additive-models-and-spline-regressions-in-r/"/>
        <id>https://phileasdg.github.io/phileas-dazeley-gaist/an-exploration-of-the-logistic-function-using-general-additive-models-and-spline-regressions-in-r/</id>
            <category term="undergraduate work"/>
            <category term="programming"/>
            <category term="R"/>

        <updated>2022-03-27T23:00:44-04:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure14-2.png" alt="" />
                    In this project, I will build nonlinear models using spline regressions, and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure14-2.png" alt="" />
                <p>In this project, I will build nonlinear models using spline regressions, and a general additive model to predict the initial conditions of sets of points of the bifurcation diagram (final state diagram) of the logistic function:</p>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/logistic_equation.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/logistic_equation-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/logistic_equation-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/logistic_equation-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/logistic_equation-lg.png 1024w"  alt="" width="382" height="55"></figure>
<h2>The bifurcation diagram of the logistic equation</h2>
<p>First, let’s briefly explore the bifurcation diagram of the logistic equation, which we can plot using the code below:</p>
<pre class="r"><code class="hljs">logistic_eq &lt;- <span class="hljs-keyword">function</span>(x, r){<span class="hljs-keyword">return</span>(r*x*(<span class="hljs-number">1</span>-x))}

x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=<span class="hljs-number">500</span>) <span class="hljs-comment"># r scale</span>
y &lt;- c()

bifurcation_data &lt;- <span class="hljs-keyword">function</span>(r_values, x_0, min_iter=<span class="hljs-number">101</span>, max_iter=<span class="hljs-number">300</span>){
  <span class="hljs-keyword">for</span>(r <span class="hljs-keyword">in</span> r_values){
    new_y &lt;- x_0
    orbit &lt;- c()
    <span class="hljs-keyword">for</span>(i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>:max_iter){
      new_y &lt;- logistic_eq(new_y, r)
      <span class="hljs-keyword">if</span>(i &lt;  min_iter){<span class="hljs-keyword">next</span>}
      orbit &lt;- c(orbit, new_y)
    }
    y &lt;- c(y, tibble(orbit))
  }
  <span class="hljs-keyword">return</span>(tibble(x_0=x_0, r=x, final_state=y, iter_num=rep(tibble(min_iter:max_iter), 
                                                          length(r_values))))
}</code></pre>
<pre class="r"><code class="hljs">x_0 &lt;- <span class="hljs-number">0.5</span>

head(bifurcation_data(x, x_0))</code></pre>
<pre><code class="hljs">## # A tibble: 6 × 4
##     x_0       r final_state  iter_num    
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;named list&gt; &lt;named list&gt;
## 1   0.5 0       &lt;dbl [200]&gt;  &lt;int [200]&gt; 
## 2   0.5 0.00802 &lt;dbl [200]&gt;  &lt;int [200]&gt; 
## 3   0.5 0.0160  &lt;dbl [200]&gt;  &lt;int [200]&gt; 
## 4   0.5 0.0240  &lt;dbl [200]&gt;  &lt;int [200]&gt; 
## 5   0.5 0.0321  &lt;dbl [200]&gt;  &lt;int [200]&gt; 
## 6   0.5 0.0401  &lt;dbl [200]&gt;  &lt;int [200]&gt;</code></pre>
<pre class="r"><code class="hljs">bifurcation_data(x, x_0) %&gt;% unnest(everything()) %&gt;% ggplot(aes(r, final_state)) + 
  geom_point(size=<span class="hljs-number">0.01</span>) + 
  labs(title=paste0(<span class="hljs-string">"Bifurcation diagram of the logistic equation for x_0 = "</span>, x_0)) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure1-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure1-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure1-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure1-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>The bifurcation diagram of the logistic equation, (also known as a final state diagram), shows the orbits of the logistic function <span class="math inline"><span id="MathJax-Element-2-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;#x2212;&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span id="MathJax-Span-22" class="math"><span id="MathJax-Span-23" class="mrow"><span id="MathJax-Span-24" class="msubsup"><span id="MathJax-Span-25" class="mi">x</span><span id="MathJax-Span-26" class="texatom"><span id="MathJax-Span-27" class="mrow"><span id="MathJax-Span-28" class="mi">n</span><span id="MathJax-Span-29" class="mo">+</span><span id="MathJax-Span-30" class="mn">1</span></span></span></span><span id="MathJax-Span-31" class="mo">=</span><span id="MathJax-Span-32" class="mi">r</span><span id="MathJax-Span-33" class="msubsup"><span id="MathJax-Span-34" class="mi">x</span><span id="MathJax-Span-35" class="mi">n</span></span><span id="MathJax-Span-36" class="mo">(</span><span id="MathJax-Span-37" class="mn">1</span><span id="MathJax-Span-38" class="mo">−</span><span id="MathJax-Span-39" class="msubsup"><span id="MathJax-Span-40" class="mi">x</span><span id="MathJax-Span-41" class="mi">n</span></span><span id="MathJax-Span-42" class="mo">)</span></span></span><span class="MJX_Assistive_MathML" role="presentation">xn+1=rxn(1−xn)</span></span></span> for values of <span class="math inline"><span id="MathJax-Element-3-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-43" class="math"><span id="MathJax-Span-44" class="mrow"><span id="MathJax-Span-45" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> between 0 and 1. The resolution of the plot/set is determined by the cardinality of the set of <span class="math inline"><span id="MathJax-Element-4-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-46" class="math"><span id="MathJax-Span-47" class="mrow"><span id="MathJax-Span-48" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> values used as the x axis, and the number of iterations computed by the <code>bifurcation_data()</code> function, plotted on the y axis. In the plot above, orbits were computed for 301 iterations, (iterations 0 to 300 as it is specified in the code), but the points corresponding to the first 101 iterations were skipped, resulting in a plot that ignores the beginning of the orbits. We could also choose to not skip iterates, which would result in a plot like the following:</p>
<p><strong>A plot of the bifurcation diagram points for x_0 = 0.5, with no iterates skipped:</strong></p>
<pre class="r"><code class="hljs">bifurcation_data(x, x_0, <span class="hljs-number">0</span>, <span class="hljs-number">300</span>) %&gt;% unnest(everything()) %&gt;% ggplot(aes(r, final_state)) + 
  geom_point(size=<span class="hljs-number">0.01</span>) + 
  labs(title=paste0(<span class="hljs-string">"Bifurcation diagram of the logistic equation for x_0 = "</span>, x_0)) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure2.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure2-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure2-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure2-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure2-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>For ease of computation and interpretability, in this project I will first constitute a working data set from which to produce visualisations and models from low-resolution data sets of points on the bifurcation diagram of the logistic equation. The resolution in r values and in number of iterations will be <code>resolution</code>, and <code>resolution</code> respectively, with no iterates skipped. I have plotted an example below:</p>
<p><strong>A plot of the lower resolution bifurcation diagram points for x_0 = 0.5:</strong></p>
<pre class="r"><code class="hljs">resolution &lt;- <span class="hljs-number">10</span> <span class="hljs-comment"># resolution, in number of units per dimension</span>

x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=resolution) <span class="hljs-comment"># r scale</span>
bifurcation_data(x, x_0, <span class="hljs-number">0</span>, resolution-<span class="hljs-number">1</span>) %&gt;% unnest(everything()) %&gt;% ggplot(aes(r, final_state)) + 
  geom_point(size=<span class="hljs-number">0.01</span>) + 
  labs(title=paste0(<span class="hljs-string">"Bifurcation diagram of the logistic equation for x_0 = "</span>, x_0)) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure3-2.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure3-2-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure3-2-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure3-2-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure3-2-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<h2>Data generation and formatting</h2>
<p>Now that we’re a bit more comfortable with bifurcation diagram of the logistic equation conceptually, let’s collect the data we’ll need to visualise variation of initial conditions, and from which we could build a model to predict the initial conditions used to generate a set of points using iterations of the logistic equations for values in the set of <span class="math inline"><span id="MathJax-Element-5-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-49" class="math"><span id="MathJax-Span-50" class="mrow"><span id="MathJax-Span-51" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> values <code>x</code>.</p>
<p>The following code will give us <code>resolution</code> r resolution by <code>resolution</code> iteration resolution point sets for <code>resolution</code> initial condition values between 0 and 1. Together, these variables form a <span class="math inline"><span id="MathJax-Element-6-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msup&gt;&lt;/math&gt;"><span id="MathJax-Span-52" class="math"><span id="MathJax-Span-53" class="mrow"><span id="MathJax-Span-54" class="mi">r</span><span id="MathJax-Span-55" class="mi">e</span><span id="MathJax-Span-56" class="mi">s</span><span id="MathJax-Span-57" class="mi">o</span><span id="MathJax-Span-58" class="mi">l</span><span id="MathJax-Span-59" class="mi">u</span><span id="MathJax-Span-60" class="mi">t</span><span id="MathJax-Span-61" class="mi">i</span><span id="MathJax-Span-62" class="mi">o</span><span id="MathJax-Span-63" class="msubsup"><span id="MathJax-Span-64" class="mi">n</span><span id="MathJax-Span-65" class="mn">3</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation">resolution3</span></span></span> resolution 3d space which that data will occupy.</p>
<p>We’ll use a little higher resolution settings for our visualisations and data exploration:</p>
<pre class="r"><code class="hljs">resolution &lt;- <span class="hljs-number">60</span> <span class="hljs-comment"># resolution, in number of units per dimension</span>

x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=resolution) <span class="hljs-comment"># r scale</span>
min_iter &lt;- <span class="hljs-number">0</span>; max_iter &lt;- resolution-<span class="hljs-number">1</span>
x_0s &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, length=resolution)

data &lt;- tibble()
<span class="hljs-keyword">for</span>(x_0 <span class="hljs-keyword">in</span> x_0s){
  data &lt;- bind_rows(data, bifurcation_data(r=x, x_0, min_iter, max_iter))
}</code></pre>
<p>Let’s preview the data by peeking at the data tibble:</p>
<pre class="r"><code class="hljs">head(data)</code></pre>
<div id="data-generation-and-formatting" class="section level2">
<pre><code class="hljs">## # A tibble: 6 × 4
##     x_0      r final_state  iter_num    
##   &lt;dbl&gt;  &lt;dbl&gt; &lt;named list&gt; &lt;named list&gt;
## 1     0 0      &lt;dbl [60]&gt;   &lt;int [60]&gt;  
## 2     0 0.0678 &lt;dbl [60]&gt;   &lt;int [60]&gt;  
## 3     0 0.136  &lt;dbl [60]&gt;   &lt;int [60]&gt;  
## 4     0 0.203  &lt;dbl [60]&gt;   &lt;int [60]&gt;  
## 5     0 0.271  &lt;dbl [60]&gt;   &lt;int [60]&gt;  
## 6     0 0.339  &lt;dbl [60]&gt;   &lt;int [60]&gt;</code></pre>
</div>
<div id="data-exploration-and-visualisation" class="section level2">
<h2>Data exploration and visualisation</h2>
<p>Let’s also preview the data graphically altogether as a scatter plot:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  ggplot(aes(r, final_state, colour=x_0)) + 
  geom_point(size=<span class="hljs-number">0.01</span>) + 
  scale_colour_gradientn(colours = rainbow(<span class="hljs-number">10</span>)) + <span class="hljs-comment"># + theme(legend.position = "none")</span>
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure4.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure4-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure4-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure4-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure4-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>The scatter plot gives us limited insight because values are stacked upon one another. But we can plot the x_0 axis in the third dimension, as a 3d point cloud, as below:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% plot_ly(data=., 
                                          x = ~r, 
                                          y = ~x_0, 
                                          z = ~final_state,
                                          color = ~iter_num,
                                          colors=viridis(<span class="hljs-number">50</span>, alpha = <span class="hljs-number">1</span>, begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">1</span>, direction = <span class="hljs-number">1</span>),
                                          marker = list(size = <span class="hljs-number">1</span>,
                                                        colorbar=list(title=<span class="hljs-string">"iteration number"</span>),
                                                        reversescale=<span class="hljs-literal">F</span>)) %&gt;% 
  add_markers() %&gt;% 
  layout(scene=list(xaxis = list(title = <span class="hljs-string">"r"</span>),
                    yaxis = list(title = <span class="hljs-string">"x_0"</span>),
                    zaxis = list(title = <span class="hljs-string">"final state"</span>), 
                    camera = list(eye = list(x = -<span class="hljs-number">1.25</span>, y = <span class="hljs-number">1.25</span>, z = <span class="hljs-number">1.25</span>))))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure5.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure5-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure5-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure5-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure5-lg.png 1024w"  alt="" width="1404" height="890"></figure>
<p>Note that the structure produced by the point cloud in the plot above has symmetry along the <code>x_0</code> axis. This tells us that for any r value and iteration step, a function cannot approach the orbit values for an initial condition between 0 and 1, as there will be two initial conditions for which the orbits are identical.</p>
<p>However, all hope is not lost! The good news is that we can make a cheaper model that will work just as well! All we need to do is to cut the data set in half so as to contain only <span class="math inline"><span id="MathJax-Element-7-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span id="MathJax-Span-66" class="math"><span id="MathJax-Span-67" class="mrow"><span id="MathJax-Span-68" class="msubsup"><span id="MathJax-Span-69" class="mi">x</span><span id="MathJax-Span-70" class="mn">0</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation">x0</span></span></span> values above or below <span class="math inline"><span id="MathJax-Element-8-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0.5&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-71" class="math"><span id="MathJax-Span-72" class="mrow"><span id="MathJax-Span-73" class="mn">0.5</span></span></span><span class="MJX_Assistive_MathML" role="presentation">0.5</span></span></span> to obtain non-mirrored data for which the orbit coordinates for an iteration step and r value can be approached by a deterministic function.</p>
<p>While we’re at it, let’s also visualise how the orbits gravitate towards a shape constituted of final states as the logistic equation is iterated:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% plot_ly(data=., 
                                          x = ~r, 
                                          y = ~iter_num, 
                                          z = ~final_state,
                                          color = ~x_0,
                                          colors=viridis(<span class="hljs-number">50</span>, alpha = <span class="hljs-number">1</span>, begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">1</span>, direction = <span class="hljs-number">1</span>),
                                          marker = list(size = <span class="hljs-number">1</span>,
                                                        reversescale=<span class="hljs-literal">F</span>)) %&gt;% 
  add_markers() %&gt;% 
  layout(scene=list(xaxis = list(title = <span class="hljs-string">"r"</span>),
                    yaxis = list(title = <span class="hljs-string">"iteration number"</span>),
                    zaxis = list(title = <span class="hljs-string">"orbit values"</span>), 
                    camera = list(eye = list(x = -<span class="hljs-number">1.25</span>, y = <span class="hljs-number">1.25</span>, z = <span class="hljs-number">1.25</span>))))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure6.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure6-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure6-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure6-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure6-lg.png 1024w"  alt="" width="1324" height="886"></figure>
<p>And let’s observe how the initial condition <span class="math inline"><span id="MathJax-Element-9-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span id="MathJax-Span-74" class="math"><span id="MathJax-Span-75" class="mrow"><span id="MathJax-Span-76" class="msubsup"><span id="MathJax-Span-77" class="mi">x</span><span id="MathJax-Span-78" class="mn">0</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation">x0</span></span></span> affects the orbit values at different iterations:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% plot_ly(data=., 
                                          x = ~x_0, 
                                          y = ~iter_num, 
                                          z = ~final_state,
                                          color = ~r,
                                          colors=viridis(<span class="hljs-number">50</span>, alpha = <span class="hljs-number">1</span>, begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">1</span>, direction = <span class="hljs-number">1</span>),
                                          marker = list(size = <span class="hljs-number">1</span>,
                                                        reversescale=<span class="hljs-literal">F</span>)) %&gt;% 
  add_markers() %&gt;% 
  layout(scene=list(xaxis = list(title = <span class="hljs-string">"x_0"</span>),
                    yaxis = list(title = <span class="hljs-string">"iteration number"</span>),
                    zaxis = list(title = <span class="hljs-string">"orbit values"</span>), 
                    camera = list(eye = list(x = <span class="hljs-number">1.25</span>, y = -<span class="hljs-number">1.25</span>, z = <span class="hljs-number">1.25</span>))))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure7.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure7-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure7-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure7-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure7-lg.png 1024w"  alt="" width="1232" height="902"></figure>
<p>Let’s take slices of <span class="math inline"><span id="MathJax-Element-10-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span id="MathJax-Span-79" class="math"><span id="MathJax-Span-80" class="mrow"><span id="MathJax-Span-81" class="msubsup"><span id="MathJax-Span-82" class="mi">x</span><span id="MathJax-Span-83" class="mn">0</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation">x0</span></span></span> by final state at different iteration numbers values and have a look at the shapes they form. But first, let’s generate higher resolution data to get nicer, more detailed plots.</p>
<pre class="r"><code class="hljs">resolution &lt;- <span class="hljs-number">200</span> <span class="hljs-comment"># resolution, in number of units per dimension</span>
x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=resolution) <span class="hljs-comment"># r scale</span>
min_iter &lt;- <span class="hljs-number">0</span>; max_iter &lt;- <span class="hljs-number">100</span>
x_0s &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, length=resolution)

data &lt;- tibble()
<span class="hljs-keyword">for</span>(x_0 <span class="hljs-keyword">in</span> x_0s){
  data &lt;- bind_rows(data, bifurcation_data(r=x, x_0, min_iter, max_iter))
}</code></pre>
<p>Let’s preview a few slices:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% filter(iter_num==iter_num[<span class="hljs-number">1</span>]) %&gt;% 
  ggplot(aes(x_0, final_state, alpha=r)) + geom_point(size=<span class="hljs-number">0.1</span>) + 
  labs(title=paste0(<span class="hljs-string">"Orbit value by initial condition for iterate "</span>, <span class="hljs-number">1</span>),
       y=<span class="hljs-string">"orbit values"</span>) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure8.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure8-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure8-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure8-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure8-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% filter(iter_num==iter_num[<span class="hljs-number">5</span>]) %&gt;% 
  ggplot(aes(x_0, final_state, alpha=r)) + geom_point(size=<span class="hljs-number">0.1</span>) + 
  labs(title=paste0(<span class="hljs-string">"Orbit value by initial condition for iterate "</span>, <span class="hljs-number">5</span>),
       y=<span class="hljs-string">"orbit values"</span>) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure9.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure9-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure9-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure9-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure9-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% filter(iter_num==iter_num[<span class="hljs-number">25</span>]) %&gt;% 
  ggplot(aes(x_0, final_state, alpha=r)) + geom_point(size=<span class="hljs-number">0.1</span>) + 
  labs(title=paste0(<span class="hljs-string">"Orbit value by initial condition for iterate "</span>, <span class="hljs-number">25</span>),
       y=<span class="hljs-string">"orbit values"</span>) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure10.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure10-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure10-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure10-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure10-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% filter(iter_num==iter_num[<span class="hljs-number">50</span>]) %&gt;% 
  ggplot(aes(x_0, final_state, alpha=r)) + geom_point(size=<span class="hljs-number">0.1</span>) + 
  labs(title=paste0(<span class="hljs-string">"Orbit value by initial condition for iterate "</span>, <span class="hljs-number">50</span>),
       y=<span class="hljs-string">"orbit values"</span>) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure11.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure11-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure11-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure11-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure11-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% filter(iter_num==iter_num[<span class="hljs-number">100</span>]) %&gt;% 
  ggplot(aes(x_0, final_state, alpha=r)) + geom_point(size=<span class="hljs-number">0.1</span>) + 
  labs(title=paste0(<span class="hljs-string">"Orbit value by initial condition for iterate "</span>, <span class="hljs-number">100</span>),
       y=<span class="hljs-string">"orbit values"</span>) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure12.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure12-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure12-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure12-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure12-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>Optionally, we couls save an image sequence for <code>iter_num</code> values</p>
<pre class="r"><code class="hljs"><span class="hljs-comment"># iter_num &lt;- min_iter:max_iter</span>
<span class="hljs-comment"># for(i in iter_num){ # add in [1:10] when done with animation</span>
<span class="hljs-comment">#   plot &lt;- data %&gt;% unnest(everything()) %&gt;% filter(iter_num==i) %&gt;%</span>
<span class="hljs-comment">#     ggplot(aes(x_0, final_state, alpha=r/4)) +</span>
<span class="hljs-comment">#     geom_point(size=0.1) +</span>
<span class="hljs-comment">#     labs(title=paste0("Orbit value by initial condition for iterate ", i),</span>
<span class="hljs-comment">#          y = "orbit values") +</span>
<span class="hljs-comment">#     theme_tufte()</span>
<span class="hljs-comment">#   ggsave(paste0("image sequences/final state by initial condition by iterate line plot/", "orbit values by initial condition for iterate ", i, ".png"),</span>
<span class="hljs-comment">#          width=30, height=20, units="cm")</span>
<span class="hljs-comment"># }</span></code></pre>
<p>The code above results in the following animation sequence: <span class="math inline"><span id="MathJax-Element-11-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mrow href=&quot;https://youtu.be/mmFu3PikEsc&quot;&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mo&gt;:&lt;/mo&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mo&gt;/&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;/mrow&gt;&lt;/math&gt;"><span id="MathJax-Span-84" class="math"><span id="MathJax-Span-85" class="mrow"><span id="MathJax-Span-86" class="mrow"><span id="MathJax-Span-87" class="mi">h</span><span id="MathJax-Span-88" class="mi">t</span><span id="MathJax-Span-89" class="mi">t</span><span id="MathJax-Span-90" class="mi">p</span><span id="MathJax-Span-91" class="mi">s</span><span id="MathJax-Span-92" class="mo">:</span><span id="MathJax-Span-93" class="texatom"><span id="MathJax-Span-94" class="mrow"><span id="MathJax-Span-95" class="mo">/</span></span></span><span id="MathJax-Span-96" class="texatom"><span id="MathJax-Span-97" class="mrow"><span id="MathJax-Span-98" class="mo">/</span></span></span><span id="MathJax-Span-99" class="mi">y</span><span id="MathJax-Span-100" class="mi">o</span><span id="MathJax-Span-101" class="mi">u</span><span id="MathJax-Span-102" class="mi">t</span><span id="MathJax-Span-103" class="mi">u</span><span id="MathJax-Span-104" class="mo">.</span><span id="MathJax-Span-105" class="mi">b</span><span id="MathJax-Span-106" class="mi">e</span><span id="MathJax-Span-107" class="texatom"><span id="MathJax-Span-108" class="mrow"><span id="MathJax-Span-109" class="mo">/</span></span></span><span id="MathJax-Span-110" class="mi">m</span><span id="MathJax-Span-111" class="mi">m</span><span id="MathJax-Span-112" class="mi">F</span><span id="MathJax-Span-113" class="mi">u</span><span id="MathJax-Span-114" class="mn">3</span><span id="MathJax-Span-115" class="mi">P</span><span id="MathJax-Span-116" class="mi">i</span><span id="MathJax-Span-117" class="mi">k</span><span id="MathJax-Span-118" class="mi">E</span><span id="MathJax-Span-119" class="mi">s</span><span id="MathJax-Span-120" class="mi">c</span></span></span></span></span></span></p>
<p>Let’s reset the resolution to our working resolution:</p>
<pre class="r"><code class="hljs">resolution &lt;- <span class="hljs-number">60</span> <span class="hljs-comment"># resolution, in number of units per dimension</span>
x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=resolution) <span class="hljs-comment"># r scale</span>
min_iter &lt;- <span class="hljs-number">0</span>; max_iter &lt;- resolution-<span class="hljs-number">1</span>
x_0s &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, length=resolution)

data &lt;- tibble()
<span class="hljs-keyword">for</span>(x_0 <span class="hljs-keyword">in</span> x_0s){
  data &lt;- bind_rows(data, bifurcation_data(r=x, x_0, min_iter, max_iter))
}</code></pre>
<p>Finally, let’s observe how orbit values for different iteration steps and initial conditions form a 3d object with a fuzzy or spiky upper boundary in the <span class="math inline"><span id="MathJax-Element-12-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-121" class="math"><span id="MathJax-Span-122" class="mrow"><span id="MathJax-Span-123" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> dimension.</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% mutate(orbit_values=final_state) %&gt;% 
  plot_ly(data=., 
          x = ~x_0, 
          y = ~iter_num, 
          z = ~r,
          color = ~orbit_values,
          colors=viridis(<span class="hljs-number">50</span>, alpha = <span class="hljs-number">1</span>, begin = <span class="hljs-number">0</span>, end = <span class="hljs-number">1</span>, direction = <span class="hljs-number">1</span>) ,
          marker = list(size = <span class="hljs-number">1</span>,
                        reversescale=<span class="hljs-literal">F</span>,
                        opacity = ~final_state)) %&gt;% 
  add_markers() %&gt;% 
  layout(scene=list(xaxis = list(title = <span class="hljs-string">"x_0"</span>),
                    yaxis = list(title = <span class="hljs-string">"iteration number"</span>),
                    zaxis = list(title = <span class="hljs-string">"r"</span>)))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure13.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure13-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure13-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure13-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure13-lg.png 1024w"  alt="" width="1274" height="906"></figure>
<h2>Model-planning considerations</h2>
<p>Now that we have a solid understanding of the shape of our data set, we can design a modelling approach.</p>
<p>The goal is to predict the initial condition <span class="math inline"><span id="MathJax-Element-13-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span id="MathJax-Span-124" class="math"><span id="MathJax-Span-125" class="mrow"><span id="MathJax-Span-126" class="msubsup"><span id="MathJax-Span-127" class="mi">x</span><span id="MathJax-Span-128" class="mn">0</span></span></span></span><span class="MJX_Assistive_MathML" role="presentation">x0</span></span></span> used to produce a bifurcation diagram. In other words, we are going to construct a model using <code>final_state</code> orbit values + <code>r</code> + <code>iter_num</code> to predict <code>x_0</code>.</p>
<p>I hypothesise that it will be easier to produce models with high predictive power and reliability for early iterations, and for <span class="math inline"><span id="MathJax-Element-14-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-129" class="math"><span id="MathJax-Span-130" class="mrow"><span id="MathJax-Span-131" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> values under 3, but that predictive power will tend to be harder to maintain for later iterations, or most values or <span class="math inline"><span id="MathJax-Element-15-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-132" class="math"><span id="MathJax-Span-133" class="mrow"><span id="MathJax-Span-134" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> above 3.</p>
<p>We can confirm this hypothesis quite easily: Firstly, simply compare the orbit values for an initial condition at earlier iterations to those at later iterations. You will see that the earlier iterations result in distinct plots which overlap little and appear to be approachable by the curves of a function. Conversely, later iterations, such as those 55 and above plotted below appear less describable by curves due to their chaotic behaviour, and overlap exactly in the non-chaotic regions of the plot.</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(iter_num&lt;<span class="hljs-number">5</span>) %&gt;% filter(x_0==x_0s[<span class="hljs-number">25</span>]) %&gt;% 
  ggplot(aes(r, final_state, colour=as.factor(iter_num))) + 
  geom_line(aes(group=as.factor(iter_num))) +
  geom_point(alpha=<span class="hljs-number">0.4</span>) +
  theme_tufte() +
  labs(title=paste0(<span class="hljs-string">"Bifurcation diagram of the logistic map points \nfor x_0 = "</span>, 
                    round(x_0s[<span class="hljs-number">25</span>], <span class="hljs-number">2</span>),<span class="hljs-string">" and iterates [0 - 5)"</span>), y=<span class="hljs-string">"orbit values"</span>) +
  theme(legend.position = <span class="hljs-string">"none"</span>)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure14.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure14-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure14-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure14-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure14-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(iter_num&gt;=<span class="hljs-number">55</span>) %&gt;% filter(x_0==x_0s[<span class="hljs-number">25</span>]) %&gt;% 
  ggplot(aes(r, final_state, colour=as.factor(iter_num))) + 
  geom_line(aes(group=as.factor(iter_num))) +
  geom_point(alpha=<span class="hljs-number">0.4</span>) +
  theme_tufte() +
  labs(title=paste0(<span class="hljs-string">"Bifurcation diagram of the logistic map points \nfor x_0 = "</span>, 
                    round(x_0s[<span class="hljs-number">25</span>], <span class="hljs-number">2</span>),<span class="hljs-string">" and iterates [55 - 60)"</span>), y=<span class="hljs-string">"orbit values"</span>) +
  theme(legend.position = <span class="hljs-string">"none"</span>)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure15.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure15-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure15-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure15-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure15-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>We can also note that points where <span class="math inline"><span id="MathJax-Element-16-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mo&gt;&amp;#x2265;&lt;/mo&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/math&gt;"><span id="MathJax-Span-135" class="math"><span id="MathJax-Span-136" class="mrow"><span id="MathJax-Span-137" class="mi">r</span><span id="MathJax-Span-138" class="mo">≥</span><span id="MathJax-Span-139" class="mn">3</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r≥3</span></span></span> are less approachable by curves. Comparing the following plots should help convey this behaviour more intiutively:</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(r==x[<span class="hljs-number">15</span>]) %&gt;% 
  ggplot(aes(iter_num, final_state, colour=as.factor(x_0))) + 
  geom_line(aes(group=as.factor(x_0)), alpha=<span class="hljs-number">0.2</span>) +
  labs(title=paste0(<span class="hljs-string">"Orbits for different initial conditions, r = "</span>, 
                    round(x[<span class="hljs-number">15</span>], <span class="hljs-number">3</span>)), x=<span class="hljs-string">"x_n"</span>, y=<span class="hljs-string">"orbit values"</span>) + 
  theme_tufte() +
  theme(legend.position = <span class="hljs-string">"none"</span>)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure16.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure16-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure16-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure16-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure16-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(r==x[<span class="hljs-number">20</span>]) %&gt;% 
  ggplot(aes(iter_num, final_state, colour=as.factor(x_0))) + 
  geom_line(aes(group=as.factor(x_0)), alpha=<span class="hljs-number">0.2</span>) +
  labs(title=paste0(<span class="hljs-string">"Orbits for different initial conditions, r = "</span>, 
                    round(x[<span class="hljs-number">20</span>], <span class="hljs-number">3</span>)), x=<span class="hljs-string">"x_n"</span>, y=<span class="hljs-string">"orbit values"</span>) + 
  theme_tufte() +
  theme(legend.position = <span class="hljs-string">"none"</span>)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure17.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure17-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure17-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure17-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure17-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(r==x[<span class="hljs-number">59</span>]) %&gt;% 
  ggplot(aes(iter_num, final_state, colour=as.factor(x_0))) + 
  geom_line(aes(group=as.factor(x_0)), alpha=<span class="hljs-number">0.2</span>) +
  labs(title=paste0(<span class="hljs-string">"Orbits for different initial conditions, r = "</span>, 
                    round(x[<span class="hljs-number">59</span>], <span class="hljs-number">3</span>)), x=<span class="hljs-string">"x_n"</span>, y=<span class="hljs-string">"orbit values"</span>) + 
  theme_tufte() +
  theme(legend.position = <span class="hljs-string">"none"</span>)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure18.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure18-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure18-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure18-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure18-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<h2>Model</h2>
<p>We’ve seen from the data exploration above that we should build our model on a subset of the data composed of early iterates orbit values, at one value of R.</p>
<pre class="r"><code class="hljs">resolution &lt;- <span class="hljs-number">200</span> <span class="hljs-comment"># resolution, in number of units per dimension</span>
x &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, length=resolution) <span class="hljs-comment"># r scale</span>
min_iter &lt;- <span class="hljs-number">0</span>; max_iter &lt;- resolution-<span class="hljs-number">1</span>
x_0s &lt;- seq(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, length=resolution)

data &lt;- tibble()
<span class="hljs-keyword">for</span>(x_0 <span class="hljs-keyword">in</span> x_0s){
  data &lt;- bind_rows(data, bifurcation_data(r=x, x_0, min_iter, max_iter))
}</code></pre>
<p>Let’s start by selecting values to test our proof of concept.</p>
<pre class="r"><code class="hljs">model_iterate_value &lt;- <span class="hljs-number">0</span>
model_r_value &lt;- x[round(resolution/<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)]</code></pre>
<p>Now, let’s split our data into training and testing sets.</p>
<pre class="r"><code class="hljs">set.seed(<span class="hljs-number">1</span>)

data_unnested &lt;- data %&gt;% unnest(everything()) %&gt;% 
  filter(x_0 &lt;= <span class="hljs-number">0.5</span>) %&gt;% 
  filter(iter_num == model_iterate_value) %&gt;% filter(r == model_r_value)

index &lt;- createDataPartition(data_unnested$x_0, p = <span class="hljs-number">.8</span>, list=<span class="hljs-literal">FALSE</span>)
training_data &lt;- data_unnested[ index,]
test_data  &lt;- data_unnested[-index,]</code></pre>
<p>And let’s create our training vectors from the training data set.</p>
<pre class="r"><code class="hljs">x_0 &lt;- training_data$x_0 
final_state &lt;- training_data$final_state

IV &lt;- final_state <span class="hljs-comment"># predictor variables</span>
DV &lt;- x_0 <span class="hljs-comment"># response variable</span></code></pre>
<p>We’re finally ready! Let’s run a smooth spline regression on our training data, and test it on our test data set.</p>
<pre class="r"><code class="hljs"><span class="hljs-comment"># Let's try to perform a smooth spline regression:</span>
final_smooth_model &lt;- npreg::ss(DV, IV)
final_smooth_model</code></pre>
<pre><code class="hljs">## 
## Call:
## npreg::ss(x = DV, y = IV)
## 
## Smoothing Parameter  spar = -0.3288175   lambda = 2.509954e-10
## Equivalent Degrees of Freedom (Df) 54.60317
## Penalized Criterion (RSS) 1.517007e-10
## Generalized Cross-Validation (GCV) 1.881561e-11</code></pre>
<pre class="r"><code class="hljs">summary(final_smooth_model)</code></pre>
<pre><code class="hljs">## 
## Call:
## npreg::ss(x = DV, y = IV)
## 
## Residuals:
##        Min         1Q     Median         3Q        Max 
## -5.400e-06 -1.858e-07  5.613e-09  1.779e-07  9.054e-06 
## 
## Approx. Signif. of Parametric Effects:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   0.3308  3.046e-07 1086254        0 ***
## x             0.4975  3.368e-06  147709        0 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
## 
## Approx. Signif. of Nonparametric Effects:
##             Df    Sum Sq   Mean Sq   F value Pr(&gt;F)    
## s(x)      52.6 1.104e-01 2.099e-03 351395897      0 ***
## Residuals 25.4 1.517e-10 5.973e-12                     
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 
## 
## Residual standard error: 2.444e-06 on 25.4 degrees of freedom
## Multiple R-squared:  1,    Adjusted R-squared:  1
## F-statistic: 344834510 on 53.6 and 25.4 DF,  p-value: &lt;2e-16</code></pre>
<pre class="r"><code class="hljs">final_smooth_model$fit$knot</code></pre>
<pre><code class="hljs">##  [1] 0.000000000 0.005025126 0.015075377 0.025125628 0.030150754 0.045226131
##  [7] 0.050251256 0.055276382 0.070351759 0.075376884 0.085427136 0.090452261
## [13] 0.095477387 0.110552764 0.120603015 0.130653266 0.135678392 0.140703518
## [19] 0.150753769 0.155778894 0.170854271 0.180904523 0.190954774 0.195979899
## [25] 0.201005025 0.216080402 0.221105528 0.241206030 0.246231156 0.251256281
## [31] 0.261306533 0.266331658 0.281407035 0.286432161 0.296482412 0.311557789
## [37] 0.316582915 0.326633166 0.336683417 0.346733668 0.356783920 0.361809045
## [43] 0.371859296 0.376884422 0.396984925 0.402010050 0.407035176 0.417085427
## [49] 0.422110553 0.432160804 0.437185930 0.442211055 0.452261307 0.457286432
## [55] 0.482412060 0.487437186 0.497487437</code></pre>
<pre class="r"><code class="hljs">length(final_smooth_model$fi$knot)</code></pre>
<pre><code class="hljs">## [1] 57</code></pre>
<pre class="r"><code class="hljs">pred &lt;- predict(final_smooth_model, test_data$x_0)
print(paste(<span class="hljs-string">"RMSE:"</span>, rmse(pred$y, test_data$x_0)))</code></pre>
<pre><code class="hljs">## [1] "RMSE: 0.0919509218319031"</code></pre>
<pre class="r"><code class="hljs">test_data %&gt;% 
        ggplot(aes(x = final_state, y = x_0)) + 
        stat_smooth(method = <span class="hljs-string">"gam"</span>, formula = y ~ bs(x, k = <span class="hljs-number">50</span>), color = <span class="hljs-string">"springgreen3"</span>) +
        geom_point() + 
        labs(x = <span class="hljs-string">"orbit values"</span>, y = <span class="hljs-string">"x_0"</span>, 
       title = paste0(<span class="hljs-string">"Smooth spline regression on orbit values \nof the logistic equation at iterate = "</span>, 
                      model_iterate_value, <span class="hljs-string">", and r = "</span>, round(model_r_value, <span class="hljs-number">2</span>))) + 
        theme_tufte() </code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure19.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure19-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure19-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure19-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure19-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>Excellent! But can we do better? What if we tried to fit a spline of any degree on our data?</p>
<pre class="r"><code class="hljs"><span class="hljs-comment"># We can also fit a spline of any degree, which in this case, should give us excellent results: </span>
any_degree_spline_model &lt;- lm(DV ~ ns(IV, df = <span class="hljs-number">12</span>), data = data_unnested)
summary(any_degree_spline_model)</code></pre>
<pre><code class="hljs">## 
## Call:
## lm(formula = DV ~ ns(IV, df = 12), data = data_unnested)
## 
## Residuals:
##        Min         1Q     Median         3Q        Max 
## -0.0053647 -0.0000552 -0.0000012  0.0000517  0.0067825 
## 
## Coefficients:
##                     Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)       -9.551e-05  9.459e-04  -0.101     0.92    
## ns(IV, df = 12)1   8.115e-02  1.268e-03  64.007   &lt;2e-16 ***
## ns(IV, df = 12)2   1.196e-01  1.621e-03  73.759   &lt;2e-16 ***
## ns(IV, df = 12)3   1.594e-01  1.470e-03 108.406   &lt;2e-16 ***
## ns(IV, df = 12)4   1.995e-01  1.571e-03 126.951   &lt;2e-16 ***
## ns(IV, df = 12)5   2.421e-01  1.544e-03 156.777   &lt;2e-16 ***
## ns(IV, df = 12)6   2.854e-01  1.577e-03 180.897   &lt;2e-16 ***
## ns(IV, df = 12)7   3.266e-01  1.533e-03 213.047   &lt;2e-16 ***
## ns(IV, df = 12)8   3.665e-01  1.507e-03 243.251   &lt;2e-16 ***
## ns(IV, df = 12)9   4.079e-01  1.461e-03 279.250   &lt;2e-16 ***
## ns(IV, df = 12)10  4.268e-01  1.126e-03 378.958   &lt;2e-16 ***
## ns(IV, df = 12)11  5.091e-01  2.381e-03 213.851   &lt;2e-16 ***
## ns(IV, df = 12)12  4.666e-01  8.857e-04 526.773   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 0.001356 on 67 degrees of freedom
## Multiple R-squared:  0.9999, Adjusted R-squared:  0.9999 
## F-statistic: 7.731e+04 on 12 and 67 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="r"><code class="hljs">pred &lt;- predict(any_degree_spline_model, test_data)</code></pre>
<pre><code class="hljs">## Warning: 'newdata' had 20 rows but variables found have 80 rows</code></pre>
<pre class="r"><code class="hljs">print(paste(<span class="hljs-string">"RMSE:"</span>, RMSE(pred, test_data$x_0)))</code></pre>
<pre><code class="hljs">## [1] "RMSE: 0.176476254615616"</code></pre>
<pre class="r"><code class="hljs">test_data %&gt;% 
  ggplot(aes(x = final_state, y = x_0)) + 
  geom_smooth(method = lm, color = <span class="hljs-string">"springgreen3"</span>, 
              formula = y ~ ns(x, df = <span class="hljs-number">12</span>)) + 
  geom_point() + 
  labs(x = <span class="hljs-string">"orbit values"</span>, y = <span class="hljs-string">"x_0"</span>, 
       title = paste0(<span class="hljs-string">"Any degree spline regression on orbit values \nof the logistic equation at iterate = "</span>, 
                      model_iterate_value, <span class="hljs-string">", and r = "</span>, round(model_r_value, <span class="hljs-number">2</span>))) +
  theme_tufte()</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure20.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure20-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure20-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure20-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure20-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>Perfect! That’s a really stellar fit! (But it makes sense, because the original data came from a smooth clean function!) In principle, it should be possible to choose any slice of the original data set for unique iterate number and r value combinations, and perform a spline regression on them to very reliably predict the initial condition used to generate the set of points on the bifurcation diagram of the logistic equation.</p>
<p>Talking about slices is all fine and dandy, but what exactly do I mean? Let’s take a look at the next plot to get a better idea! Note: in the following plot, the slice on which we built our last model is coloured in red.</p>
<p><strong>Examining the space of possible models visually:</strong> This is also the same as looking at a multivariate model in 3d, in fact now that I’ve mentioned multivariate models, let’s make a multivariate model corresponding to this surface!</p>
<pre class="r"><code class="hljs">data %&gt;% unnest(everything()) %&gt;% 
  filter(iter_num == model_iterate_value) %&gt;% 
  mutate(r_focus=if_else(r==model_r_value, <span class="hljs-literal">T</span>, <span class="hljs-literal">F</span>)) %&gt;% 
  filter(x_0 &lt; <span class="hljs-number">0.5</span>) %&gt;% 
  plot_ly(data=., 
          x = ~r, 
          y = ~x_0, 
          z = ~final_state, 
          color = ~r_focus,
          colors = c(<span class="hljs-string">"turquoise"</span>, <span class="hljs-string">"red"</span>),
          marker = list(size = <span class="hljs-number">1</span>,
                        reversescale=<span class="hljs-literal">F</span>)) %&gt;% 
  add_markers() %&gt;%
  layout(title = paste0(<span class="hljs-string">"Model surface: all models approachable \nby splines for initial conditions \nbetween 0 and 1, at iteration step "</span>, model_iterate_value),
         scene=list(xaxis = list(title = <span class="hljs-string">"r"</span>),
                    yaxis = list(title = <span class="hljs-string">"x_0"</span>),
                    zaxis = list(title = <span class="hljs-string">"orbit values"</span>), 
                    camera = list(eye = list(x = -<span class="hljs-number">1.25</span>, y = <span class="hljs-number">1.25</span>, z = <span class="hljs-number">1.25</span>))))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure21.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure21-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure21-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure21-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure21-lg.png 1024w"  alt="" width="1216" height="942"></figure>
<p>Note that if we change the iteration step, we get a different surface. Here is the surface we would have got if we had chosen to take a slice of the data at the 10th iteration step:</p>
<pre class="r"><code class="hljs">iterate_value &lt;- <span class="hljs-number">10</span>

data %&gt;% unnest(everything()) %&gt;% 
  filter(iter_num == iterate_value) %&gt;% 
  filter(x_0 &lt; <span class="hljs-number">0.5</span>) %&gt;% 
  plot_ly(data=., 
          x = ~r, 
          y = ~x_0, 
          z = ~final_state, 
          colors = <span class="hljs-string">"turquoise"</span>,
          marker = list(size = <span class="hljs-number">1</span>,
                        reversescale=<span class="hljs-literal">F</span>)) %&gt;% 
  add_markers() %&gt;%
  layout(title = paste0(<span class="hljs-string">"Model surface: all models approachable \nby splines for initial conditions \nbetween 0 and 1, at iteration step "</span>, iterate_value),
         scene=list(xaxis = list(title = <span class="hljs-string">"r"</span>),
                    yaxis = list(title = <span class="hljs-string">"x_0"</span>),
                    zaxis = list(title = <span class="hljs-string">"orbit values"</span>), 
                    camera = list(eye = list(x = -<span class="hljs-number">1.25</span>, y = <span class="hljs-number">1.25</span>, z = <span class="hljs-number">1.25</span>))))</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure22.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure22-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure22-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure22-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure22-lg.png 1024w"  alt="" width="900" height="950"></figure>
<div id="model" class="section level2">
<p>From the plot, you can see that the point cloud becomes harder to describe with a surface past 3 units along the <span class="math inline"><span id="MathJax-Element-17-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;/math&gt;"><span id="MathJax-Span-140" class="math"><span id="MathJax-Span-141" class="mrow"><span id="MathJax-Span-142" class="mi">r</span></span></span><span class="MJX_Assistive_MathML" role="presentation">r</span></span></span> axis. This indicates it would be harder to approach it with a spline model.</p>
</div>
<div id="multivariate-model" class="section level2">
<h2>Multivariate model</h2>
<p>Let’s try to model x_0 from all orbit values and values of r for an iterate value at once:</p>
<pre class="r"><code class="hljs">set.seed(<span class="hljs-number">1</span>)

data_unnested &lt;- data %&gt;% unnest(everything()) %&gt;% 
  filter(x_0 &lt;= <span class="hljs-number">0.5</span>) %&gt;% filter(iter_num == model_iterate_value)

index &lt;- createDataPartition(data_unnested$x_0, p = <span class="hljs-number">.8</span>, list=<span class="hljs-literal">FALSE</span>)
training_data &lt;- data_unnested[ index,]
test_data  &lt;- data_unnested[-index,]</code></pre>
<pre class="r"><code class="hljs">bifurcation_gam_multivariate &lt;- gam(x_0 ~ s(final_state) + s(r), data = training_data)
summary(bifurcation_gam_multivariate)</code></pre>
<pre><code class="hljs">## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## x_0 ~ s(final_state) + s(r)
## 
## Parametric coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 0.2485989  0.0005742     433   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Approximate significance of smooth terms:
##                  edf Ref.df    F p-value    
## s(final_state) 8.982  9.000 5327  &lt;2e-16 ***
## s(r)           8.756  8.983 3017  &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## R-sq.(adj) =   0.75   Deviance explained =   75%
## GCV = 0.0052814  Scale est. = 0.0052752  n = 16000</code></pre>
<pre class="r"><code class="hljs">predictions_gam &lt;- predict(bifurcation_gam_multivariate, test_data)
RMSE(predictions_gam, test_data$x_0)</code></pre>
<pre><code class="hljs">## [1] 0.07323365</code></pre>
<pre class="r"><code class="hljs">plot(bifurcation_gam_multivariate)</code></pre>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure23.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure23-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure23-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure23-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure23-lg.png 1024w"  alt="" width="1344" height="960"></figure><figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/figure24.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure24-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure24-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure24-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/11/responsive/figure24-lg.png 1024w"  alt="" width="1344" height="960"></figure>
<p>Also excellent!</p>
<p>I am curious to try to apply models to later iteration steps, but for now I feel this project has gone on enough, and you probably have other stuff to get to, so I’ll come back to it later.</p>
<p>These models are all such good fits that if makes little sense to compare them. However, hopefully this exploration has served more than to show that a spline regression model can be used to predict initial conditions used to generate sets of points from bifurcation diagrams of the logistic map, as long as we have access to early iteration steps. Beyond that, my hope is that this exploration will provide readers with more insight into the shape and properties of the bifurcation diagram of the logistic equation, a mathematical object which is now ubiquitous throughout mathematical literature.</p>
</div>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Mathematical Systems Thinking for Human Ecology</title>
        <author>
            <name>Phileas Dazeley-Gaist</name>
        </author>
        <link href="https://phileasdg.github.io/phileas-dazeley-gaist/mathematical-systems-thinking-for-human-ecology/"/>
        <id>https://phileasdg.github.io/phileas-dazeley-gaist/mathematical-systems-thinking-for-human-ecology/</id>
            <category term="undergraduate work"/>

        <updated>2022-03-27T22:58:37-04:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/lsystem1.png" alt="" />
                    The Human Ecology of differential equations A reflection on the places and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/lsystem1.png" alt="" />
                <div class="page" title="Page 1">
<div class="section">
<div class="layoutArea">
<div class="column">
<h2>The Human Ecology of differential equations</h2>
<div class="page" title="Page 1">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>A reflection on the places and roles of mathematics in human ecological undertakings would without a doubt be misleading if it were not to include mention of differential equations and their long history of being used for dynamical systems modelling.</p>
<p>Differential equations are a classic tool for dynamical systems modelling, as they offer researchers a starting point from which to model real-world interactions in environments without having to know the exact processes that underly them. In essence, they allow researchers to study the dynamics of a system from derivatives of the ”exact processes” functions that compose it, and depending on whether a system of differential equations is solvable, that is to say, whether one can arrive at the definitive ”exact process” functions that the differential equations of the system are derivatives of, they may allow researchers to model a given dynamic system completely.</p>
<p>Differential equations are the go-to tool for complex dynamical systems modelling and analysis, and are used extensively to model physical, chemical, and purely mathematical processes. From the beginning of the century to the mid-1970s, ecologists, meteorologists, and financiers attempted to apply the same techniques to their fields (see for instance the work of Edward Lorenz or Stephen Smale). Ecologists and social scientists, including human ecologists use these approaches extensively (see An Ecological Introduction, K. E. Boulding, 1950, or Complex ecosystem and sustainable development, Ma Shijun &amp; Wang Rusong, 1990) But while these attempts in some cases revealed new facets of mathe- matics, they generally failed to do what they set out to achieve. Why?</p>
<p>The answer lies in the features of naturally occurring systems. In a controlled environment, sets of ”exact processes” functions can be enforced as axioms of a closed system, outside functions apply to a system and manage its behaviour. In that case, systems of differential equations may be an appropriate modelling tool. Sadly, there’s a big catch: In the wide wide world we live in, most naturally occurring systems are adaptive, meaning as their dynamics evolve, the ”exact processes” functions that constitute an adaptive system change, are in unpredictable and constant flux. The cause for these changes is that the ”exact processes” functions are part of the systems themselves, and dependent on material and relational processes that occur within the respective systems, which are described by other ”exact processes” functions. The interactions between these functions can form extensive networks which describe intricate mixes of flows, stocks, and transformations. Differential equations can model Dynamic Systems but not Adaptive Systems. For this latter type of system, differential equations are of no help at all.</p>
<div class="page" title="Page 1">
<div class="section">
<div class="layoutArea">
<div class="column">
<h2>Do we need to model everything?</h2>
<div class="page" title="Page 1">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>Before I reflect on other mathematical techniques and philosophies, and how I feel they relate to Human Ecology and could find their place in human ecological dialogue, I would like to consider the modes of <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">apprehension of the world that emboldened many researcher throughout history to attempt to model the natural world.</span></p>
<div class="page" title="Page 2">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>It is not self-evident that the world needs to be modelled. In fact, the world exists already, it’s out there waiting for us, what use is a copy of the process to us if it is only a shadow of the real thing? Why not go out and enjoy it in person? There are so many ways of learning about the world and the systems within it. Often neglected is hands-on learning one can earn from experiencing the world from within: physically and emotionally, to be consumed and surrounded by the experience of being, feeling, seeing, and touching.</p>
<p>For my part, I like to think that while experiential learning in the world is a primordial need which all should get to experience, there is still a place for analysis, deconstruction, and quantitative reason- ing. For one, all of these things are part of the world too, they are aspects of our environment. If human ecology concerns itself with human-environment interactions and the place of human beings in an ecology, then we should see mathematics mathematics as an essentially human ecological venture. Mathematics are a secretive language of nature which rarely shares its secrets. While counting is not an exclusively human trait, the depth and variety of human counting techniques are unique in the animal world.</p>
<p>In the natural sciences, I believe the desire to model and replicate nature as an attempt to under- stand it can be traced back to European materialism, utilitarianism, and determinist philosophy of 17th century Europe. These frameworks travelled extensively through trade, and through the colonial rule and subjugation of nation states by European powers, and spread rapidly worldwide. I bring this up not to brush off the desire to model nature as an outdated cultural relic, but to illustrate that it is a worldview that exists in continuity with the cultures and writing of a very small group of people in a very small part of the world, and at a very specific time in history. We are perhaps needlessly limiting ourselves to a relationship to nature which in some capacity must factor in this lens.</p>
<p>I’ll end on counting as an interesting subject: counting - what counts? Pun intended. Do trees count? Are the processes through which trees grow and multiply, branch, and ache cognisant enough to count as ”counting”? Or are they just material reactions? And does it matter? Can an animate but inorganic process count?</p>
<div class="page" title="Page 2">
<div class="section">
<div class="layoutArea">
<div class="column">
<h2>Not-entirely deterministic systems</h2>
<div class="page" title="Page 2">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>As a language of nature, mathematics has the enviable property that its descriptions of mathematical phenomena transcend mathematics into all dimensions of the natural world. If a mathematical phe- nomenon produces a certain type of behaviour, and as observers, we notice a similar phenomenon in nature, we can be quite certain certain that the natural phenomenon is related to the mathematical one. Even though the same process may not be a play in either one, both share a sameness, and this sameness opens a pathway to mathematics ←→ nature exchanges.</p>
<p>We are used to using mathematics to discover Nature, or using mathematics to explain it, but we hardly ever hear of the reverse: using nature to explore mathematics, to explain mathematics, or even as a map to mathematical exploration.</p>
<p>I have a strong hunch that mathematics discovered through this process, especially mathematical processes and algorithms discovered through such an approach would replicate the properties of pro- cesses that occur in nature. These processes would often be not entirely deterministic, part of not entirely deterministic systems, of which we understand very little today. Exploration of mathematics through nature might yield (with some luck and creative thinking) insight into the inner functioning of <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">complex adaptive systems, and help us breakaway from a purely normative or descriptive understand- ing of mathematics which sees mathematics as either dictating nature’s inner workings, or passively reflecting it. Mathematics are a conceptual framework that abstracts relationships that occur in nature, but we only have use for mathematics insofar as they describe the nature that they are a part of. How could nature not describe maths, just as mathematical assertions assert the dynamics, relationships, and laws of nature?</span></p>
<div class="page" title="Page 3">
<div class="section">
<div class="layoutArea">
<div class="column">
<h2>Mathematics as a shimmer through a lens</h2>
<div class="page" title="Page 3">
<div class="section">
<div class="layoutArea">
<div class="column">
<p>To close this reflection piece, I’d like to consider one outcome of using nature as an exploratory tool for maths: L-systems.</p>
<p>L-systems are formal systems which use a combination of rules or substitution of symbols of a formal language for others using sometimes deterministic, sometimes stochastic, and sometimes a com- bination of both rules. L-systems were first discovered by Aristid Lindenmayer, a biologist who studied the growth patterns of bacteria such as the Anabaena catenula. Lindenmayer originally intended these systems to provide a formal description of the development of bacteria, and to illustrate the neigh- bourhood relationships between plant cells. However, they were quickly extended to describe larger organisms with branching structures such as plants.</p>
<p>The following figures showcase some structures generated through L-systems. As you view them, I would like to invite you to think of them not as a flawed mathematical representation of nature, but as a beautiful human enabled nature-informed representation of maths.</p>
<div class="gallery-wrapper"><div class="gallery"  data-is-empty="false" data-translation="Add images" data-columns="3">
<figure class="gallery__item"><a href="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem1.png" data-size="1802x786"><img loading="lazy" src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem1-thumbnail.png" alt="" width="768" height="335"></a></figure>
<figure class="gallery__item"><a href="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem2.png" data-size="1838x1200"><img loading="lazy" src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem2-thumbnail.png" alt="" width="768" height="501"></a></figure>
<figure class="gallery__item"><a href="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem3.png" data-size="1202x1146"><img loading="lazy" src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/10/gallery/lsystem3-thumbnail.png" alt="" width="768" height="732"></a></figure>
</div></div>
<div class="page" title="Page 4">
<div class="section">
<div class="layoutArea">
<div class="column">
<p><strong>Note:</strong> L-system models generated using Vlab on macOS, generously provided courtesy of the Al- gorithmic Botany lab at University of Calgary.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Standing Stones and Megaliths of St Just - A GIS project</title>
        <author>
            <name>Phileas Dazeley-Gaist</name>
        </author>
        <link href="https://phileasdg.github.io/phileas-dazeley-gaist/standing-stones-and-megaliths-of-st-just/"/>
        <id>https://phileasdg.github.io/phileas-dazeley-gaist/standing-stones-and-megaliths-of-st-just/</id>
            <category term="undergraduate work"/>

        <updated>2022-03-21T16:08:55-04:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/9/menhirs-2.JPG" alt="" />
                    I constructed the following ESRI ArcGIS StoryMap project for the college course&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/9/menhirs-2.JPG" alt="" />
                <p>I constructed the following ESRI ArcGIS StoryMap project for the college course "Geographic Information Systems" taught by Professor Gordon Longsworth at the College of the Atlantic, in Fall 2020. I have embedded it below as a sample of my undergraduate GIS work. </p>
<p>Although you are free to consult the project on this page, I recommend you follow <a href="https://storymaps.arcgis.com/stories/3edd0a80cd114d02af9bdeb1b446d30b">this link</a> for a much enhanced and improved screenwide StoryMap experience.</p>
<div class="post__iframe"><iframe loading="lazy" width="100%" height="500px" src="https://storymaps.arcgis.com/stories/3edd0a80cd114d02af9bdeb1b446d30b?cover=false" frameborder="0" allowfullscreen="allowfullscreen" allow="geolocation"></iframe></div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Tracking Icebergs: Exploring the Mathematics of Iceberg Drift and Decay Models</title>
        <author>
            <name>Phileas Dazeley-Gaist</name>
        </author>
        <link href="https://phileasdg.github.io/phileas-dazeley-gaist/tracking-icebergs/"/>
        <id>https://phileasdg.github.io/phileas-dazeley-gaist/tracking-icebergs/</id>
            <category term="undergraduate work"/>

        <updated>2022-03-21T23:39:23-04:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/Iceberg_Ilulissat.jpg" alt="CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid&#x3D;730855" />
                    I wrote this short essay for the college course "Polar Ecology and&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/Iceberg_Ilulissat.jpg" alt="CC BY-SA 3.0, https://commons.wikimedia.org/w/index.php?curid&#x3D;730855" />
                <div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
<p>I wrote this short essay for the college course "Polar Ecology and Exploration" taught by Professor Sean Todd at College of the Atlantic in Winter 2020. I have reproduced it here as a sample of my undergraduate writing. </p>
<h2>Introduction</h2>
<p>This paper will explore and contextualise the principles and methods at the centre of contemporary iceberg drift and decay mathematical models. To do so, it will first examine the incentives for institutional efforts to track drifting icebergs. Secondly, this paper will engage in an extensive introductory exploration of iceberg drift and decay approximation formulas and dynamic and thermodynamic models and assess their respective strengths and limitations. Finally, it will describe the process of running a modern drift and decay model simulation using MATLAB and report the raw simulation results.</p>
<h3>Incentives for Iceberg tracking</h3>
<p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Icebergs are large masses of freshwater ice that form by breaking apart from a glacier, ice shelf, or larger icebergs, a process known as calving (Iceberg | Ice Formation, n.d.). In the Antarctic Circle, icebergs calve from the floating ice shelves of the Antarctic continent, which results in large and tall icebergs with steep cliff-like sides and flat tops, known as tabular icebergs (Ibid). In the Arctic, icebergs calve from glaciers, particularly those of Greenland (Ibid). NOAA’s National Ocean Service defines minimum characteristics of icebergs (according to the standard set by the International Ice Patrol) as follows:</span></p>
<div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
<p>“To be classified as an iceberg, the height of the ice must be greater than 16 feet above sea level and the thickness must be 98-164 feet and the ice must cover an area of at least 5,382 square feet.” (US Department of Commerce, n.d.)</p>
<p>One incentive for iceberg tracking and monitoring is risk minimisation. While even the smallest ice objects that satisfy these criteria easily pose threats to ships and offshore ventures, among others, larger icebergs, which can reach a freeboard (height above the waterline) of above 100 metres and individual mass exceeding 10,000,000 tonnes (100 times the typical mass of the smallest icebergs) pose additional and greatly increased threats to their surroundings as they drift (Iceberg Classification Systems, n.d.).</p>
<div class="page" title="Page 1">
<div class="layoutArea">
<div class="column">
<p>Other incentives for iceberg monitoring are scientific: Melting icebergs could contain clues to the processes behind ice-shelf collapse (Icebergs | National <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">Snow and Ice Data Center, n.d.). If so, their study could contribute to our understanding of global warming. As they melt, icebergs release freshwater into the ocean, suggesting that in large enough numbers, drifting icebergs could affect ocean circulation (Ibid). Furthermore, as they melt, icebergs disperse nutrients into the ocean, leaving trails of nutrient-rich freshwater, which attracts marine life and could therefore be of interest to marine biologists (Ibid).</span></p>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
<p>Mathematical iceberg drift and decay models are powerful tools that, given accurate data, can assist researchers and institutions by predicting where they might expect to find icebergs or estimating the future drift of existing icebergs given an initial location to calculate from. These applications are desirable because of the high cost of real-world iceberg tracking, which is typically done via satellite imagery, aerial surveys, and sighting reporting from merchant and scientific ships (Icebergs | National Snow and Ice Data Center, n.d.).</p>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
<h2>Drift and Decay</h2>
<p>While some simple approximation formulas exist to estimate iceberg drift and decay, these tend to produce somewhat caricatured predictions that are unsuitable for most research purposes. Among more complex mathematical models, some are probabilistic, but most sophisticated contemporary models are deterministic and incorporate thermodynamics in their predictions. This section will present iceberg drift and decay approximation methods, explore the principal essential components of these modern models, and assess their strengths and limitations.</p>
<h3>Approximation Formulas</h3>
<p>Although they lack precision, approximation rules for iceberg drift and decay are helpful in that they are speedy.</p>
<p>A frequent estimate of iceberg drift velocity is that it approximately equals 2% of the wind velocity relative to the ocean current (Smith, 1993). The approximation holds true for most cases in the Arctic, where small icebergs and strong winds are common, but does not in the Antarctic, where the combination of weak winds and generally larger icebergs render the effect of wind on iceberg drift negligible (Wagner et al., 2017).</p>
<p>In their report for the CRREL titled Some Elements of Iceberg Technology, W. F. Weeks and M. Mellor propose the following iceberg ice loss formula:</p>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-1.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-1-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-1-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-1-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-1-lg.png 1024w"  alt="figure 1: Z = K * Delta" width="141" height="45"></figure>
<div class="page" title="Page 2">
<div class="layoutArea">
<div class="column">
<p>Where Z is the total ice loss at any point of an iceberg’s journey in metres, ∆ is the sum of mean daily water temperatures around the draught of the iceberg for <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">every day of an iceberg’s drift in degrees Celsius, and K is a constant ~ 0.12. This formula appears rather infrequently in scientific literature and should be used cautiously.</span></p>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
<p>While potentially useful for navigation and small-scale, short-term predictions of iceberg drift and decay, these shortcuts tend to produce skewed results, which can deviate significantly from real-world observations. For this reason, scientists should generally avoid them in research.</p>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
<h3>Dynamic and Thermodynamic Models</h3>
<p>Modelling the dynamics and thermodynamics of icebergs, published in 1997 and co-authored by Grant R. Bigg, Martin R. Wadley, David P. Stevens, and John A. Johnson, is a foundational paper for the admittedly very niche field of iceberg drift modelling. The paper proposes the following momentum equation of horizontal iceberg motion:</p>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-2.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-2-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-2-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-2-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-2-lg.png 1024w"  alt="figure 2: M*(dV_i/dt) = -M*f*k*x*V_i+F_a+F_w+F_i+F_p+F+r" width="844" height="132"></figure>
<p>Where M is the iceberg's mass (kg), and V_i is the horizontal velocity (m*s^-1). <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">The </span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">components of the equation F_a, F_w, F_i, F_p, and F_r are respectively air and wind </span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">drag (F_a), water drag (F_w), sea ice drag (F_i), the horizontal pressure gradient force </span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">the water around the iceberg exerts on the volume that the iceberg displaces (F_p), </span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">water and wave drag (F_w), and the wave radiation force (F_r), while f is the Coriolis </span><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">parameter, a value equal to 2Ω * sin phi, where Ω is the rate of rotation of the Earth, and phi is latitude (Holton &amp; Hakim, 2012) (reported in rad*s^-1) (Bigg et al., 1997).</span></p>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
<p>Since the mass of an iceberg reduces as the iceberg drifts, melts, and sometimes breaks up into smaller pieces, it is important to note that in practice, the equation described above only reveals an iceberg’s momentum at a given point of its life: it does not account for iceberg decay. The equation returns the momentum of any iceberg given its mass and velocity. However, alone, its applications to iceberg drift modelling are limited because drift is affected by each modelled iceberg’s length, width, and mass (Wagner et al., 2017). To account for the gradual change in mass and dimensions of drifting icebergs, Bigg et al. (1997) describe and propose methods to jointly model iceberg thermodynamics. They write:</p>
<div class="page" title="Page 3">
<div class="layoutArea">
<div class="column">
<blockquote>
<p>“The melting of an iceberg constantly changes its mass and shape, and thus must be modelled in any long-term simulation of trajectories... The melting/erosional processes that have been included are ‘basal’ convection or turbulent heat transfer, buoyant <span style="font-family: var(--font-serif); color: var(--text-primary-color); font-size: inherit;">convection, wave erosion, solar and sensible heating, and sublimation.” (p. 117)</span></p>
</blockquote>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
<p>Among the melt processes they list, the dominant three according to Till J. W. Wagner, Rebecca W. Dell, and Ian Eisenman (2017) are wind-driven wave erosion (mechanical) M_e, turbulent basal melt (thermal) – melting at the base of the iceberg; described as turbulent because the melting basal layer is sandwiched between the cold of the ice and the relative warmth of the water, forming a transitional volume of turbulent convection (Ahlers, 2009) – M_b, and thermal sidewall erosion from buoyant convection – erosion of iceberg sidewalls from changes in ice surface temperature due to variations in iceberg buoyancy (Convection, n.d.) – noted M_v. In their paper, An Analytical Model of Iceberg Drift, the authors incorporate these factors in their own iceberg drift and decay model but discard the other thermodynamic factors described by Bigg et al. (1997), which they assert are negligible in comparison to the others. Their formulation of the equations for these three factors are:</p>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-3.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-3-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-3-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-3-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-3-lg.png 1024w"  alt="figure 3" width="1488" height="738"></figure>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
<p>For the purposes of this paper, it will suffice to mention that these equations solve for the changes in mass, length (L), width (W), and height (H) of modelled icebergs, and that the dimensions of modelled icebergs change as</p>
<figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-4.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-4-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-4-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-4-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-4-lg.png 1024w"  alt="figure 4" width="282" height="238"></figure>
<div class="page" title="Page 4">
<div class="layoutArea">
<div class="column">
<p>As should be evident, solving these equations requires data on the conditions of any modelled iceberg’s immediate environment, most importantly sea state, sea surface temperature, and atmospheric temperature estimates. Many models, including the one proposed by Wagner et al. (2017) source these data from </p>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
<p>NASA’s “Estimating the Circulation and Climate of the Ocean” (ECCO) consortium, or NCAR and UCAR’s Community Climate System Model (CCSM).</p>
<p>By sequentially solving the iceberg momentum and decay equations, feeding the results of the momentum equation into the decay equations and vice versa, we can calculate and plot the trajectory of an iceberg starting at any given latitudinal and longitudinal coordinates (a monumental task which researchers typically undertake programmatically) (Eisenman et al., 2021). The accuracy of the results produced using this method makes the use of momentum and decay equations in models attractive, and their use is now common in iceberg drift and decay models. Variations of the formulas first described by Bigg et al. (1997) are at the core of many iceberg drift and decay modelling tools today, programs such as MITberg, a MATLAB project developed by Alan Condron at the University of Massachusetts and designed to be used with MIT’s general circulation model (MITgcm), (MITberg: Icebergs and Climate Change, n.d.), itself a program designed to model fluid dynamics in the Earth ocean and atmosphere (MITgcm User Manual, n.d.). Other examples include OpenBerg, a python module for use with the python ocean drift modelling library OpenDrift (Opendrift.Models.Openberg — OpenDrift Documentation, n.d.), Elmer/Ice, an add-on package to the Elmer FEM (finite element method) program, which is designed to model ice dynamics (Elmer Ice - Home, n.d.), and FESOM-IB, a module designed for the Finite-Element/VolumE Sea-ice Ocean Model (Rackow et al., 2013).</p>
<div class="page" title="Page 5">
<div class="layoutArea">
<div class="column">
<p>The main advantages of dynamic and thermodynamic deterministic models of iceberg drift and decay over approximations and probabilistic models reside in the increased precision and reliability of their results when compared to real-world observational data (for an example, see Figure 1). In fact, they so surpass probabilistic models that these have largely fallen out of use. However, with this gained precision come challenges and drawbacks: high computational power requirements for long time scale or large iceberg sample simulations due to the volume of calculations and data which the models must process with each new drift prediction step, and lower accessibility to laypeople due to the steep learning curves and sometimes high financial costs associated with the use of the frameworks (hardware and software) through which these models are accessible (typical software frameworks are high-level sometimes proprietary programs or programming languages such as MATLAB, which hosts two of the models mentioned in this paper, the Lagrangian model proposed by Wagner et al. (2017), and MITberg)</p>
<figure class="post__image" ><img loading="lazy" src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-5.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-5-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-5-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-5-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-5-lg.png 1024w"  alt="figure 5: a) Observed iceberg trajectories using data from the Antarctic Iceberg Tracking Database. b) One-year duration simulated trajectories for 200 icebergs of lengths ranging between 15 and 20 km using the drift and decay model proposed by Wagner et al. (2017). (Journal of Physical Oceanography 47, 7; 10.1175/JPO-D-16-0262.1)" width="1152" height="1232">
<figcaption >
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
<p>a) Observed iceberg trajectories using data from the Antarctic Iceberg Tracking Database.<br>b) One-year duration simulated trajectories for 200 icebergs of lengths ranging between 15 and 20 km using the drift and decay model proposed by Wagner et al. (2017). (Journal of Physical Oceanography 47, 7; 10.1175/JPO-D-16-0262.1)</p>
</div>
</div>
</div>
</figcaption>
</figure>
<div class="page" title="Page 6">
<div class="layoutArea">
<div class="column">
<h2>Running a drift and decay model</h2>
<p>The model proposed by Wagner et al. (2017) is publicly available at http://eisenman.ucsd.edu/code.html, and as a MATLAB code repository on GitHub. This section will shortly describe the process of setting up and running the model using MATLAB online and report the model output generated using the described setup program parameters.</p>
<p>After downloading the model repository from GitHub and uploading it to a directory of MATLAB Drive, I accessed the main program by opening the model file named “iceberg_model_WDE17.m”. I then confirmed that my MATLAB license included access to the MATLAB mapping toolbox, which the model requires to generate iceberg drift trail maps (Eisenman et al., 2021). The program code is clear and generously annotated with usage instructions. Its first four sections allow the user to define their own model parameters. Respectively these are: 1) a model data input section where the user can specify the ocean surface and ambient atmospheric temperature data which the model requires <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">and its source (ECCO or CCSM), 2) an iceberg parameter and analytical expression definition section in which properties such as air density, water density, or C' (see the iceberg decay equations described in section II.0b), 3) a space domain definition section in which the user specifies the area in which the model will compute iceberg trajectories as well as the boundaries for map figure generation, and 4) a run parameter definition section in which the user defines the time step length, the number of iceberg trajectories to compute, iceberg seed locations, seeding spacing, iceberg dimensions, and other settings specific to the desired simulation (Eisenman et al., 2021).</span></p>
<div class="page" title="Page 7">
<div class="layoutArea">
<div class="column">
<p>For demonstration purposes, I run the model here using mostly default program settings, having only adjusted the number of iceberg trajectories to compute and the iceberg start seeds. The code output reported below are the results of a 1-year-long model projection for 25 icebergs based on 1992 ECCO data:</p>
</div>
</div>
</div>
</div>
</div>
</div>
<p> </p>
<figure ><figure class="post__image"><img loading="lazy"  src="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/iceberg-figure-6.png" sizes="(max-width: 1024px) 100vw, 1024px" srcset="https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-6-xs.png 300w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-6-sm.png 480w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-6-md.png 768w ,https://phileasdg.github.io/phileas-dazeley-gaist/media/posts/8/responsive/iceberg-figure-6-lg.png 1024w"  alt="Wagner et al. model map output showing iceberg trails grouped by size class." width="1624" height="1014"></figure>
<figcaption >
<div class="page" title="Page 7">
<div class="layoutArea">
<div class="column">
<p>Wagner et al. model map output showing iceberg trails grouped by size class.</p>
</div>
</div>
</div>
</figcaption>
</figure>
<div class="page" title="Page 8">
<div class="layoutArea">
<div class="column">
<h2>Concluding statement</h2>
<p>Mathematical models of iceberg drift and decay are incredibly useful tools that can return results accurate enough to have consequential applications to scientific research, navigation, and security monitoring, but their high computing power requirements and relatively low accessibility to laypeople limit their use outside of well-funded research projects and state-run organisations. As a student, the MATLAB licence I bought for this project cost me $125 US, but for commercial or professional uses, the same license would have cost over $2000. Despite their efficacy and reliability, the high financial or material costs of entry and overall complexity of iceberg drift and decay modelling programs remain a major obstacle to their widespread adoption.</p>
</div>
</div>
<div class="layoutArea">
<div class="column">
<h2>Sources Cited</h2>
<p>Ahlers, G. (2009). Turbulent convection. Physics, 2. https://physics.aps.org/articles/v2/74</p>
<p>Bigg, G. R., Wadley, M. R., Stevens, D. P., &amp; Johnson, J. A. (1997). Modelling the dynamics and thermodynamics of icebergs. Cold Regions Science and Technology, 26(2), 113–135. https://doi.org/10.1016/S0165-232X(97)00012-8</p>
<p>Convection. (n.d.). Retrieved 4 March 2021, from https://www.chemeurope.com/en/encyclopedia/Convection.html#Buoyancy_induced_ convection_not_due_to_heat</p>
</div>
</div>
</div>
<div class="page" title="Page 9">
<div class="layoutArea">
<div class="column">
<p>Eisenman, I., Dell, R. W., &amp; Wagner, T. J. W. (2021). Model of iceberg drift and decay (p. 5436915492 Bytes) [Data set]. figshare. https://doi.org/10.6084/M9.FIGSHARE.12857672</p>
<p>Elmer Ice–Home. (n.d.). Retrieved 4 March 2021, from https://elmerice.elmerfem.org/ Holton, J., &amp; Hakim, G. (2012). An Introduction to Dynamic Meteorology, (5th ed., Vol.88).</p>
<p>Iceberg | ice formation. (n.d.). Encyclopedia Britannica. Retrieved 4 March 2021, from https://www.britannica.com/science/iceberg</p>
<p>Iceberg Classification Systems. (n.d.). Retrieved 4 March 2021, from https://www.universalcompendium.com/tables/science/iceb.htm</p>
<p>MITberg: Icebergs and Climate Change. (n.d.). Retrieved 4 March 2021, from http://www.geo.umass.edu/faculty/condron/MITberg/download.htm</p>
<p>MITgcm user manual. (n.d.). Retrieved 4 March 2021, from https://mitgcm.readthedocs.io/en/latest/</p>
<p>opendrift.models.openberg–OpenDrift documentation. (n.d.). Retrieved 4 March 2021, from https://opendrift.github.io/autoapi/opendrift/models/openberg/index.html</p>
<p>Quick Facts on Icebergs | National Snow and Ice Data Center. (n.d.). Retrieved 4 March 2021, from https://nsidc.org/cryosphere/quickfacts/icebergs.html</p>
<p>Rackow, T., Wesche, C., Timmermann, R., &amp; Juricke, S. (2013). Modelling Southern Ocean iceberg drift and decay with FESOM-IB. EPIC3European Geophysical Union, Vienna, Austria, 2013-04-07-2013-04-12. European Geophysical Union, Vienna, Austria. https://epic.awi.de/id/eprint/37482/</p>
<p>Smith, S. D. (1993). Hindcasting iceberg drift using current profiles and winds. Cold Regions Science and Technology, 22(1), 33–45. https://doi.org/10.1016/0165- 232X(93)90044-9</p>
<p>US Department of Commerce, N. O. and A. A. (n.d.). What is an iceberg? Retrieved 4 March 2021, from https://oceanservice.noaa.gov/facts/iceberg.html</p>
<p>Wagner, T. J. W., Dell, R. W., &amp; Eisenman, I. (2017). An Analytical Model of Iceberg Drift. Journal of Physical Oceanography, 47(7), 1605–1616. https://doi.org/10.1175/JPO-D-16-0262.1</p>
<p>Weeks, W. F., &amp; Mellor, M. (1978). SOME ELEMENTS OF ICEBERG TECHNOLOGY. In A. A. Husseiny (Ed.), Iceberg Utilization (pp. 45–98). Pergamon. https://doi.org/10.1016/B978-0-08-022916-4.50015-7</p>
</div>
</div>
</div>
<p> </p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
            ]]>
        </content>
    </entry>
</feed>
